# 왜 WebFlux 를 채택하지 않았나? (Why didn't I adopt WebFlux?)

## 고려한 상황

이 서버의 경우, 통합된 로그인 서비스를 제공하기 때문에, 타 서비스 보다 많은 동시 요청이 발생할 것으로 예상하였습니다.

일차적으로는 저의 도메인 내부에 있는 서비스들이 이 서버를 통해 인증을 시도하게 될 것이고,
더 나아가서는 외부의 서비스에 auth2.0 인증을 진행해야할 것입니다.

## 후보군
따라서 다음과 같은 후보군을 생각하였습니다.

### WebFlux
고성능과 더 높은 처리량을 보여주는 WebFlux 를 사용하면 좋지 않을까 생각했습니다.
하지만 다음과 같은 문제점이 있었고, 결정적으로 추후 나올 Virtual Thread 를 사용하여 서버를 바꿀 생각이 있었기 때문에, 채택하지 않았습니다.
- _어려운 Reactive Programming_ : 기존에 진행했던 프로젝트에서 도입을 해 보았지만, 예외처리라던지, 코드 가독성이라던지, 러닝 커브 부분에서 너무 큰 단점이 보였습니다.
- _블로킹 코드에 대한 불안감_ : 아무리 고민해서 작성한다고 한들, 나의 코드의 어느 부분에서 블로킹이 발생하진 않을까 항상 걱정이 되었습니다.
- _기존 편리한 라이브러리에 대한 사용 불가_ : 기존에 편리한 라이브러리들도, 쓰레드를 기반으로하는 전통적인 방식으로 구현되었을 경우, 사용이 힘들었습니다.
- _전용 라이브러리들의 미성숙도_ : 기존 프로젝트 중 reactive 스타일로 짜여진 R2DBC를 도입했는데, 성숙도가 부족하고, 유지보수가 제대로 되지 않고 있었습니다. 또한 커뮤니티 또한 빈약했습니다.

### Serverless (AWS Lambda)
아직 후보군 입니다. 추후에 고려해보려고 합니다.
토이프로젝트이기 때문에, 요청이 많지 않을 것으로 생각되고, 로그인의 경우, 사용 중 지속적으로 요청이 발생하는 것이 아니라 사용주기 중 초기에 몰리는 경향이 있습니다.

따라서 이런 수요 변동이 큰 상황에서 어울릴 것으로 생각했습니다.

하지만 서버리스에서 내부적으로 이벤트 발생이나, 복잡한 내부 로직 처리, 다양한 미들웨어와의 연동에 대한 경험이 없었고, 이 부분이 의문이 들어서 일단 후보로 두었습니다.

## 최종 선택
결국, 기존에 사용하던 Servlet, 쓰레드풀 기반의 Spring Boot 를 사용하기로 결정하였습니다.

그리고 향후 jdk 21이 나오면, virtual thread를 사용하여 성능을 개선하는 편이 더 낫다고 생각이 들었습니다.
